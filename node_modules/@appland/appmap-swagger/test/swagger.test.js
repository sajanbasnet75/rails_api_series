/* eslint-disable no-undef */
const { glob } = require('glob');
const { promises: fsp } = require('fs');
const { parseHTTPServerRequests } = require('../util');
const Model = require('../model');

const appMapRequests = {};
const models = {};
const LOG_MODEL = process.env.DEBUG || process.env.LOG_MODEL;

// eslint-disable-next-line no-unused-vars
function logModel(model) {
  if (LOG_MODEL) {
    console.warn(JSON.stringify(model.swagger(), null, 2));
  }
}

async function loadAppMaps(dir) {
  // eslint-disable-next-line no-multi-assign
  const requests = (appMapRequests[dir] = []);
  return new Promise((resolve, reject) => {
    glob(`test/fixtures/${dir}/*.appmap.json`, async (err, fileNames) => {
      if (err) {
        reject(err);
      }

      // eslint-disable-next-line max-len
      await Promise.all(
        fileNames.map(async (fileName) => parseHTTPServerRequests(
          JSON.parse(await fsp.readFile(fileName)),
          (request) => requests.push(request),
        ))
      );
      resolve();
    });
  });
}

async function loadModel(fileName) {
  const model = new Model();
  parseHTTPServerRequests(
    JSON.parse(await fsp.readFile(fileName)),
    (request) => model.addRequest(request)
  );
  logModel(model);
  return model;
}

async function swaggerModel(dir) {
  if (!models[dir]) {
    const model = new Model();
    appMapRequests[dir].forEach((request) => model.addRequest(request));
    logModel(model);
    models[dir] = model;
  }
  return models[dir];
}

beforeAll(() => Promise.all(['appland', 'minimal'].map((dir) => loadAppMaps(dir))));

test('loads appmaps', () => {
  // eslint-disable-next-line dot-notation
  expect(appMapRequests['appland'].length).toBeGreaterThan(0);
});

test('builds appland swagger', async () => {
  const model = await swaggerModel('appland');
  expect(Object.keys(model.swagger())).toEqual(['paths', 'components']);
});

test('builds expected paths', async () => {
  const model = await swaggerModel('appland');
  expect(Object.keys(model.swagger().paths)).toEqual([
    '/api/api_keys',
    '/api/scenarios',
    '/api/scenarios/{id}',
    '/api_keys',
    '/api_keys/new',
    '/api_keys/{id}',
    '/user',
    '/{organization_id}/{id}',
    '/{organization_id}/{id}/component_diagram',
  ]);
});

test('builds expected components', async () => {
  const model = await swaggerModel('appland');
  expect(model.swagger().components).toEqual({
    securitySchemes: {
      bearer: {
        type: 'http',
        scheme: 'bearer',
      },
    },
  });
});

test('uses bearer security scheme for API method', async () => {
  const model = await swaggerModel('appland');
  expect(model.swagger().paths['/api/api_keys'].post.security).toEqual([
    {
      bearer: [],
    },
  ]);
});

test('returns JSON from API method', async () => {
  const model = await swaggerModel('appland');
  expect(
    model.swagger().paths['/api/api_keys'].post.responses['201'].content
  ).toEqual({
    'application/json': {},
  });
});

test('returns HTML from non-API method', async () => {
  const model = await swaggerModel('appland');
  expect(
    model.swagger().paths['/api_keys/new'].get.responses['200'].content
  ).toEqual({
    'text/html': {},
  });
});

test('uses unspecified security scheme for non-API method', async () => {
  const model = await swaggerModel('appland');
  expect(model.swagger().paths['/api_keys'].post.security).toBeUndefined();
});

test('requires every path parameter', async () => {
  const model = await swaggerModel('appland');
  expect(model.swagger().paths['/api_keys/{id}'].delete.parameters).toEqual([
    {
      name: 'id',
      in: 'path',
      schema: {
        type: 'string',
        example: '3',
      },
      required: true,
    },
  ]);
});

test('defines an object schema', async () => {
  const model = await swaggerModel('appland');
  expect(
    model.swagger().paths['/api_keys'].post.requestBody.content[
      'application/x-www-form-urlencoded'
    ]
  ).toEqual({
    schema: {
      type: 'object',
      properties: {
        description: {
          example: 'my new api key',
          type: 'string',
        },
        authenticity_token: {
          example: 'vxgncRaWVQf3suFTsHIikH9UZpX0+CtgQS5UZQ4vhOgfn57EDHLlts4ndE5uXHrd37LaTMatFuC3r7fAIxm6dg==',
          type: 'string',
        },
      },
    },
  });
});

test('defines an array schema', async () => {
  const model = await swaggerModel('appland');
  expect(model.swagger().paths['/api/scenarios'].get.parameters[0]).toEqual({
    name: 'code_objects',
    in: 'query',
    schema: {
      example: 'controllers',
      type: 'array',
      items: {
        type: 'string',
      },
    },
  });
});

test('produces valid output from minimal input', async () => {
  const model = await swaggerModel('minimal');
  expect(model.swagger()).toEqual({
    paths: {
      '/api/api_keys': {
        post: {
          responses: {
            201: {
              content: {},
              description: 'Created',
            },
          },
        },
      },
    },
    components: {
      securitySchemes: {},
    },
  });
});

test('handles an array-valued path_info', async () => {
  const model = await loadModel('test/fixtures/issue_specific/array_valued_path_info.appmap.json');
  expect(model.swagger().paths).toEqual({
    '/api/api_keys': {
      post: {
        responses: {
          201: {
            content: {},
            description: 'Created',
          },
        },
      },
    },
  });
});

test('recognizes swagger-style URL paths', async () => {
  const model = await loadModel('test/fixtures/issue_specific/swagger_style_normalized_path.appmap.json');
  expect(model.swagger().paths).toEqual({
    '/orgs/{org_id}': {
      get: {
        parameters: [
          {
            in: 'path',
            name: 'org_id',
            required: true,
            schema: {
              example: 'myorg',
              type: 'string'
            }
          }
        ],
        responses: {
          200: {
            content: {},
            description: 'OK',
          },
        },
      },
    },
  });
});
