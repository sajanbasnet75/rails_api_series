'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var require$$0 = require('crypto');
var sqliteParser = require('@appland/sql-parser');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
var sqliteParser__default = /*#__PURE__*/_interopDefaultLegacy(sqliteParser);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

function commonjsRequire (path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var core = createCommonjsModule(function (module, exports) {
(function (root, factory) {
	{
		// CommonJS
		module.exports = factory();
	}
}(commonjsGlobal, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined$1) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
	        crypto = commonjsGlobal.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && typeof commonjsRequire === 'function') {
	        try {
	            crypto = require$$0__default['default'];
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined$1) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
});

var sha256 = createCommonjsModule(function (module, exports) {
(function (root, factory) {
	{
		// CommonJS
		module.exports = factory(core);
	}
}(commonjsGlobal, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));
});

const hasProp = (obj, prop) =>
  Object.prototype.hasOwnProperty.call(obj, prop);

function isFalsey(valueObj) {
  if (!valueObj) {
    return true;
  }
  if (valueObj.class === 'FalseClass') {
    return true;
  }
  if (valueObj.class === 'Array' && valueObj.value === '[]') {
    return true;
  }
  if (valueObj.value === '') {
    return true;
  }

  return false;
}

function isCommand(event) {
  if (event.http_server_request) {
    return true;
  }
  if (event.codeObject.labels.has('command')) {
    return true;
  }
  return false;
}

function capitalizeString(str) {
  if (typeof str !== 'string') {
    return '';
  }

  return str.slice(0, 1).toUpperCase() + str.slice(1).toLowerCase();
}

function getHttpLabel(event) {
  if (hasProp(event, 'http_server_request') === false) {
    return null;
  }

  const requestMethod = event.http_server_request.request_method;
  const pathInfo = event.http_server_request.path_info;
  let label;

  try {
    // the url is fake, we only care about the path info anyway
    const url = new URL(pathInfo, 'http://hostname');
    label = `${requestMethod} ${url.pathname}`;
  } catch (ex) {
    label = 'HTTP Request';
  }

  return label;
}

const sqlLabels = new Set([
  'insert',
  'update',
  'select',
  'delete',
  'alter',
  'create',
  'drop',
  'rename',
  'truncate',
  'replace',
  'savepoint',
  'release',
  'rollback',
  'lock',
  'unlock',
  'set',
  'start',
  'call',
  'delete',
  'do',
  'perform',
  'handler',
  'load',
  'purge',
  'reset',
  'prepare',
  'execute',
  'deallocate',
  'xa',
]);

function getSqlLabelFromString(sqlString) {
  const sqlChars = [...sqlString.trimLeft()];
  if (sqlChars.length > 0 && sqlChars[0] === '(') {
    // if the query is wrapped in parenthesis, drop the opening parenthesis
    // it doesn't matter if we leave a hanging closing parenthesis.
    // e.g. (SELECT 1);

    sqlChars.shift();
  }

  // drop sub-queries and parenthesized expressions
  let depth = 0;
  const topLevelSql = sqlChars
    .reduce((arr, c) => {
      if (c === '(') {
        depth += 1;
      }

      if (depth === 0) {
        arr.push(c);
      }

      if (c === ')') {
        depth -= 1;
      }

      return arr;
    }, [])
    .join('');

  let queryType = null;
  if (topLevelSql.search(/\s/) === -1) {
    // There's only a single token
    // e.g. BEGIN, COMMIT, CHECKPOINT
    queryType = topLevelSql;
  } else {
    // convert non-word sequences to spaces and split by space
    // find the first known token
    queryType = topLevelSql
      .replace(/[^\w]+/g, ' ')
      .toLowerCase()
      .split(' ')
      .find((t) => sqlLabels.has(t));
  }

  return ['SQL', capitalizeString(queryType) || null].join(' ');
}
function getSqlLabel(event) {
  if (hasProp(event, 'sql_query') === false) {
    return null;
  }

  return getSqlLabelFromString(
    event.sql_query.normalized_sql || event.sql_query.sql || ''
  );
}

function getLabel(event) {
  let label = getHttpLabel(event);
  if (!label) {
    label = getSqlLabel(event);
  }
  return label;
}

function hashify(obj) {
  const clone = { ...obj };
  Object.keys(obj).forEach((key) => {
    const val = obj[key];
    if (Array.isArray(val)) {
      clone[key] = new Set(val);
    } else if (val instanceof Set) {
      clone[key] = val;
    } else if (val && typeof val === 'object') {
      clone[key] = hashify(val);
    } else {
      clone[key] = val;
    }
  });
  return clone;
}

const REPOSITORY_RESOLVERS = {
  github: (d) => {
    const match = d.url.match(/github.com[:|/]?(.*).git/);
    if (!match || match.length <= 1) {
      return null;
    }

    const hash = typeof d.lineNumber === 'number' ? `#L${d.lineNumber}` : '';
    return `https://github.com/${match[1]}/blob/${d.commit}/${d.path}${hash}`;
  },
};

function getRepositoryUrl(
  url,
  path,
  commit = 'master',
  lineNumber = null
) {
  if (url && path) {
    const d = { url, path, lineNumber, commit };
    const resolvers = Object.values(REPOSITORY_RESOLVERS);
    for (let i = 0; i < resolvers.length; i += 1) {
      const repositoryUrl = resolvers[i](d);
      if (repositoryUrl) {
        return repositoryUrl;
      }
    }
  }

  return null;
}

const UPPER = 0x1;
const LOWER = 0x10;
const getCase = (char) => (/[A-Z]/.exec(char) === null ? LOWER : UPPER);
const getCasePattern = (str) => {
  if (str.length <= 2) {
    return null;
  }

  return {
    firstCase: getCase(str[0]),
    secondCase: getCase(str[1]),
  };
};

const splitCamelCase = (str) => {
  const strLen = str.length;
  if (strLen < 1) {
    return [];
  }

  const casePattern = getCasePattern(str);
  if (!casePattern) {
    return [str];
  }

  const { firstCase, secondCase } = casePattern;
  const ret = [];
  let matched = false;
  for (let i = 2; i < strLen; i += 1) {
    const charCase = getCase(str[i]);
    if (charCase === UPPER) {
      if (firstCase === LOWER || secondCase === LOWER) {
        const token = str.slice(0, i);
        ret.push(token);
        ret.push(...splitCamelCase(str.slice(i)));
        matched = true;
        break;
      }
    } else if (
      charCase === LOWER &&
      firstCase === UPPER &&
      secondCase === UPPER
    ) {
      const token = str.slice(0, i - 1);
      ret.push(token);
      ret.push(...splitCamelCase(str.slice(i - 1)));
      matched = true;
      break;
    }
  }

  if (!matched) {
    ret.push(str);
  }

  return ret;
};

// Builds the fully qualified function name of a function (static or instance) within a
// fully qualified class name.
function fullyQualifiedFunctionName(event) {
  const label = getLabel(event);
  if (label) {
    return label;
  }

  return event.toString();
}

// tokenizeIdentifier returns tokens of an identifier split by non-alphanumeric and camel casing
// example:
//  someMethodName   -> [ 'some', 'method', 'name' ]
//  some_method_name -> [ 'some', 'method', 'name' ]
//  org.company.MyPackage.MyClass -> [ 'org', 'company', 'My', 'Package', 'My', 'Class']
function tokenizeIdentifier(id) {
  const ret = [];

  // Split first by non-alphanumeric tokens
  const tokens = (id || '').split(/[$.:#\-_]/);

  // Split remaining tokens by camel case
  tokens.forEach((token) => {
    ret.push(...splitCamelCase(token));
  });

  return ret;
}

function addHiddenProperty(obj, property, opts) {
  if (!Object.hasOwnProperty.call(obj, '$hidden')) {
    Object.defineProperty(obj, '$hidden', {
      enumerable: false,
      writable: false,
      value: {},
    });
  }

  Object.defineProperty(obj.$hidden, property, {
    enumerable: false,
    writable: true,
    ...opts,
  });
}

function buildLabels(classMap, events) {
  const result = {};

  function addLabel(label, obj, type, target) {
    /* eslint-disable no-param-reassign */
    if (!obj[label]) {
      obj[label] = {};
    }

    if (!obj[label][type]) {
      obj[label][type] = [];
    }

    obj[label][type].push(target);
    /* eslint-enable no-param-reassign */
  }

  classMap.codeObjects
    .filter((obj) => obj.labels.size)
    .forEach((codeObject) => {
      Array.from(codeObject.labels).forEach((label) => {
        addLabel(label, result, codeObject.type, codeObject);
      });
    });

  events
    .filter((event) => event.isCall() && event.labels.size)
    .forEach((event) => {
      Array.from(event.labels).forEach((label) => {
        addLabel(label, result, 'event', event);
      });
    });

  return result;
}

// sizeof returns a naive byte count for an object when serialized.
// I was using an external library for this (object-sizeof), but getting results off by a factor of
// ~2. This is awfully wasteful, slow and inaccurate but it works for now. -DB
const sizeof = (obj) => JSON.stringify(obj).length;

const DYNAMIC_FIELDS = new Set([
  'id',
  'value',
  'thread_id',
  'elapsed',
  'object_id',
  'lineno',
  'path',
]);

function getStaticPropValues(obj) {
  return Object.getOwnPropertyNames(obj)
    .filter((k) => typeof obj[k] !== 'object' && !DYNAMIC_FIELDS.has(k))
    .sort()
    .map((k) => obj[k]);
}

function buildQueryAST(sql) {
  const parseSQL = sql.replace(/\s+returning\s+\*/i, '');
  try {
    return sqliteParser__default['default'](parseSQL);
  } catch (e) {
    console.warn(`Unable to parse ${parseSQL} : ${e.message}`);
    return null;
  }
}

/* eslint-disable no-inner-declarations */
function parseNormalizeSQL(sql) {
  const ast = buildQueryAST(sql);
  if (!ast) {
    return null;
  }

  try {
    const actions = [];
    const columns = [];
    const tables = [];
    let joins = 0;

    function parse(statement) {
      const tokens = ['type', 'variant']
        .map((propertyName) => statement[propertyName])
        .filter((value) => value);

      const key = tokens.join('.');
      // eslint-disable-next-line no-use-before-define
      let parser = parsers[key];
      if (!parser) {
        // eslint-disable-next-line no-use-before-define
        parser = parseStatement;
      }

      const parserList = Array.isArray(parser) ? parser : [parser];
      parserList.forEach((prs) => prs(statement));
    }

    function parseStatement(statement) {
      const reservedWords = ['type', 'variant', 'name', 'value'];
      Object.keys(statement)
        .filter((property) => !reservedWords.includes(property))
        .map((propertyName) => statement[propertyName])
        .forEach((property) => {
          if (Array.isArray(property)) {
            property.forEach(parse);
          } else if (typeof property === 'object') {
            parse(property);
          } else if (
            typeof property === 'string' ||
            typeof property === 'boolean'
          ) {
            // pass
          } else {
            console.warn(
              `Unrecognized subexpression: ${typeof property} ${property}`
            );
          }
        });
    }

    function parseList(listElements, statement) {
      listElements.forEach((listElement) => {
        const subExpression = statement[listElement];
        if (Array.isArray(subExpression)) {
          subExpression.forEach(parse);
        } else if (typeof subExpression === 'object') {
          parse(subExpression);
        } else {
          console.warn(`Unrecognized subexpression: ${subExpression}`);
        }
      });
    }
    const nop = () => {};
    function parseIdentifierExpression(statement) {
      if (statement.format === 'table') {
        tables.push(statement.name);
      }
      parseList(['columns'], statement);
    }
    function recordAction(action) {
      return () => {
        actions.push(action);
      };
    }

    const parsers = {
      'literal.text': nop,
      'literal.decimal': nop,
      'identifier.star': (statement) => columns.push(statement.name),
      'identifier.column': (statement) => columns.push(statement.name),
      'identifier.table': (statement) => tables.push(statement.name),
      'identifier.expression': parseIdentifierExpression,
      'statement.select': [recordAction('select'), parseStatement],
      'statement.insert': [recordAction('insert'), parseStatement],
      'statement.update': [recordAction('update'), parseStatement],
      'statement.delete': [recordAction('delete'), parseStatement],
      'statement.pragma': nop,
      'map.join': [
        (statement) => {
          joins += statement.map.length;
        },
        parseStatement,
      ],
    };

    parse(ast);

    function unique(list) {
      return [...new Set(list)];
    }
    const uniqueActions = unique(actions).sort();

    return {
      actions: uniqueActions,
      tables: unique(tables).sort(),
      columns: unique(columns).sort(),
      joinCount: joins,
    };
  } catch (e) {
    console.warn(`Unable to interpret AST tree for ${sql} : ${e.message}`);
    return null;
  }
}
/* eslint-enable no-inner-declarations */

function dumbNormalizeSQL(sql) {
  const sqlLower = sql.toLowerCase().trim();
  if (sqlLower.indexOf('pragma') === 0) {
    return {
      tables: [],
      columns: [],
    };
  }

  const stopWords = ['where', 'limit', 'order by', 'group by', 'values', 'set'];
  const stopWordLocations = stopWords
    .map((word) => sqlLower.indexOf(` ${word}`))
    .filter((index) => index !== -1)
    .sort();
  if (stopWordLocations.length > 0) {
    const subSQL = sql.slice(0, stopWordLocations[0] - 1);
    return subSQL.replace(
      /\s([\w_]+)\(\s+'?[w\d]+'?\)\s+\)(?:\s|^)/g,
      '$1(...)'
    );
  }

  console.warn(`Unparseable: ${sql}`);
  return 'Unparseable';
}

/**
 * It's essential to normalize SQL to remove trivial differences like WHERE clauses on
 * generated id values, timestamps, etc.
 *
 * @param {string} sql
 */
function normalizeSQL(sql) {
  return parseNormalizeSQL(sql) || dumbNormalizeSQL(sql);
}

// #region ========= BEGIN UNUSED CODE =========
// These are called from Event.compare, but that method may be removed.
// Don't merge me!

function appMapObjectCompare(a, b) {
  if (a === b) {
    return true;
  }

  if (!a || !b) {
    return false;
  }

  const props = [
    ...new Set([
      ...Object.getOwnPropertyNames(a),
      ...Object.getOwnPropertyNames(b),
    ]),
  ].filter((k) => !DYNAMIC_FIELDS.has(k));

  // return the props that differ
  return props.filter((k) => a[k] !== b[k]);
}

function sqlCompare(a, b) {
  let { sqlQuery: sqlQueryA } = a;
  let { sqlQuery: sqlQueryB } = b;

  if (sqlQueryA === sqlQueryB) {
    return true;
  }

  if (!sqlQueryA || !sqlQueryB) {
    return false;
  }

  sqlQueryA = normalizeSQL(sqlQueryA);
  sqlQueryB = normalizeSQL(sqlQueryB);

  if (sqlQueryA.action !== sqlQueryB.action) {
    return false;
  }

  const allColumns = [...sqlQueryA.columns, ...sqlQueryB.columns];
  const allTables = [...sqlQueryA.tables, ...sqlQueryB.tables];

  return (
    allColumns.find(
      (c) => !sqlQueryA.columns.includes(c) || !sqlQueryB.columns.includes(c)
    ) === undefined &&
    allTables.find(
      (c) => !sqlQueryA.tables.includes(c) || !sqlQueryB.tables.includes(c)
    ) === undefined
  );
}

function arrayCompare(a, b) {
  if (a === b) {
    return true;
  }

  if (!a || !b) {
    return false;
  }

  const lengthA = a ? a.length || 0 : 0;
  const lengthB = b ? b.length || 0 : 0;

  if (lengthA !== lengthB) {
    return false;
  }

  for (let i = 0; i < lengthA; i += 1) {
    if (!appMapObjectCompare(a[i], b[i])) {
      return false;
    }
  }

  return true;
}

function httpCompare(a, b) {
  const {
    message: messageA,
    httpServerRequest: httpServerRequestA,
    httpServerResponse: httpServerResponseA,
  } = a;

  const {
    message: messageB,
    httpServerRequest: httpServerRequestB,
    httpServerResponse: httpServerResponseB,
  } = b;

  return (
    arrayCompare(messageA, messageB) &&
    appMapObjectCompare(httpServerRequestA, httpServerRequestB) &&
    appMapObjectCompare(httpServerResponseA, httpServerResponseB)
  );
}

function setCompare(a, b) {
  if (a === b) {
    return true;
  }

  if (!a || !b) {
    return false;
  }

  const allItems = [...new Set([...a, ...b])];
  return allItems.find((i) => !a.has(i) || !b.has(i)) === undefined;
}
// #endregion ========= END UNUSED CODE =========

function hashHttp(e) {
  const { httpServerRequest } = e;
  if (!httpServerRequest) {
    return null;
  }

  const { message, httpServerResponse } = e;
  const content = [];
  message.forEach((m) =>
    getStaticPropValues(m).forEach((v) => content.push(v))
  );
  getStaticPropValues(httpServerResponse).forEach((v) => content.push(v));
  getStaticPropValues(httpServerRequest).forEach((v) => content.push(v));

  return sha256(content.join('')).toString();
}

function hashSql(e) {
  const { sqlQuery } = e;
  if (!sqlQuery) {
    return null;
  }

  const normalizedSql = normalizeSQL(sqlQuery);
  const content = [normalizedSql.action];

  if (normalizedSql.columns) {
    normalizedSql.columns.forEach((c) => content.push(c));
  }

  if (normalizedSql.tables) {
    normalizedSql.tables.forEach((t) => content.push(t));
  }

  return sha256(content.join('')).toString();
}

// Returns a unique 'hash' (or really, a key) tied to the event's core identity: SQL, HTTP, or a
// specific method on a specific class. This is _really_ naive. The idea is that this better finds
// a singular change versus an existing object that has been removed and a new object added in its
// place.
function identityHashEvent(e) {
  if (e.httpServerRequest) {
    return 'http';
  }

  const { sqlQuery } = e;
  if (sqlQuery) {
    const queryOps = normalizeSQL(sqlQuery);
    const content = ['sql', queryOps.action, ...queryOps.tables]
      .filter(Boolean)
      .join('');
    return sha256(content).toString();
  }

  return e.toString();
}

function hashEvent(e) {
  let hash = hashHttp(e);
  if (hash) {
    return hash;
  }

  hash = hashSql(e);
  if (hash) {
    return hash;
  }

  const content = [];
  getStaticPropValues(e).forEach((v) => content.push(v));
  if (e.parameters) {
    e.parameters.forEach((p) =>
      getStaticPropValues(p).forEach((v) => content.push(v))
    );
  }

  return sha256(content.join('')).toString();
}

function resolveDifferences(arr1, arr2) {
  let arr1Index = 0;
  let arr2Index = 0;

  for (;;) {
    const a = arr1[arr1Index];
    const b = arr2[arr2Index];
    if (!a && !b) {
      return;
    }

    if (typeof a === 'undefined') {
      arr1.push(null);
      arr1Index += 1;
      arr2Index += 1;
      continue; // eslint-disable-line no-continue
    }

    if (typeof b === 'undefined') {
      arr2.push(null);
      arr1Index += 1;
      arr2Index += 1;
      continue; // eslint-disable-line no-continue
    }

    const hashA = a.identityHash;
    const hashB = b.identityHash;
    if (hashA !== hashB) {
      let instancesA = 0;
      for (let i = arr1Index + 1; i < arr1.length; i += 1) {
        instancesA += arr1[i].identityHash === hashA ? 1 : 0;
      }

      let instancesB = 0;
      for (let i = arr2Index + 1; i < arr2.length; i += 1) {
        instancesB += arr2[i].identityHash === hashA ? 1 : 0;
      }

      if (instancesA >= instancesB) {
        arr2.splice(arr2Index, 0, null);
      } else if (instancesA < instancesB) {
        arr1.splice(arr1Index, 0, null);
      } // eslint-disable-line no-continue
    }

    arr1Index += 1;
    arr2Index += 1;
  }
}

function getRootEvents(eventArray) {
  return eventArray.filter((e) => e.isCall() && !e.parent);
}

const CodeObjectType = {
  DATABASE: 'database',
  QUERY: 'query',
  HTTP: 'http',
  EXTERNAL_SERVICE: 'external-service',
  ROUTE: 'route',
  PACKAGE: 'package',
  CLASS: 'class',
  FUNCTION: 'function',
};

class CodeObject {
  constructor(data, parent) {
    this.data = { ...data };

    if (!(this.data.labels instanceof Set)) {
      this.data.labels = new Set(this.data.labels);
    }

    this.children = [];
    if (parent) {
      parent.children.push(this);
    }

    addHiddenProperty(this, 'parent', { value: parent });
    addHiddenProperty(this, 'events', { writable: false, value: [] });
  }

  get id() {
    const tokens = this.buildId();

    if (this.parent && this.type === CodeObjectType.FUNCTION) {
      const separator = this.static ? '.' : '#';
      tokens[tokens.length - 2] = separator;
    }

    return tokens.join('');
  }

  get name() {
    return this.data.name;
  }

  get type() {
    return this.data.type;
  }

  get static() {
    return this.data.static;
  }

  get location() {
    return this.data.location;
  }

  get labels() {
    return this.data.labels;
  }

  get events() {
    return this.$hidden.events;
  }

  get parent() {
    return this.$hidden.parent;
  }

  set parent(val) {
    this.$hidden.parent = val;
  }

  // Gets the source locations for this code object. For a package, no source locations are returned
  // (there would be too many to be useful). For a class, the paths to all files which add methods to the class are
  // returned. For a function, the path and line number is returned.
  get locations() {
    switch (this.type) {
      case CodeObjectType.CLASS:
        return Array.from(this.classLocations()).sort();
      case CodeObjectType.FUNCTION:
        return [this.location];
      default:
        return [];
    }
  }

  get packageOf() {
    return [this, ...this.ancestors()]
      .filter((obj) => obj.type === CodeObjectType.PACKAGE)
      .map((obj) => obj.name)
      .reverse()
      .join('/');
  }

  get classOf() {
    return [this, ...this.ancestors()]
      .filter((obj) => obj.type === CodeObjectType.CLASS)
      .map((obj) => obj.name)
      .reverse()
      .join('::');
  }

  get classObject() {
    return [this, ...this.ancestors()].find(
      (obj) => obj.type === CodeObjectType.CLASS
    );
  }

  get packageObject() {
    return [this, ...this.ancestors()].find(
      (obj) => obj.type === CodeObjectType.PACKAGE
    );
  }

  get functions() {
    if (this.type === CodeObjectType.CLASS) {
      // getting the functions of a class should not return functions of nested classes
      return this.children.filter(
        (obj) => obj.type === CodeObjectType.FUNCTION
      );
    }

    return this.descendants().filter(
      (obj) => obj.type === CodeObjectType.FUNCTION
    );
  }

  get classes() {
    return [this, ...this.descendants()].filter(
      (obj) => obj.type === CodeObjectType.CLASS && obj.functions.length
    );
  }

  get allEvents() {
    return [this, ...this.descendants()].map((obj) => obj.events).flat();
  }

  descendants() {
    const queue = [...this.children];
    const children = [];

    while (queue.length) {
      const child = queue.pop();
      children.push(child);
      queue.push(...child.children);
    }

    return children;
  }

  ancestors() {
    let currentObject = this.parent;
    const parents = [];

    while (currentObject) {
      parents.push(currentObject);
      currentObject = currentObject.parent;
    }

    return parents;
  }

  // Leafs retrieves the leaf objects for the current type that contain children of another type. It
  // is useful for retrieving children without worrying about types or deeply nested objects.
  //
  // For example, the leafs of the package "com" may be:
  // - com.myorg.myapp
  // - com.myorg.myapp.api
  //
  // Whereas its children would only contain "myorg", and its descendants would include functions
  // and classes from any other nested package.
  leafs() {
    const { type } = this;
    const queue = [this];
    const leafArray = [];

    while (queue.length) {
      const obj = queue.pop();
      const childrenOfType = obj.children.filter(
        (child) => child.type === type
      );

      // If this object has children of another type, consider it a leaf.
      // For example, a package containing a class.
      if (childrenOfType.length) {
        queue.push(...childrenOfType);
      }

      // If, however, this object has a variety of child types, it's both a leaf and a parent
      if (
        (!obj.children.length && obj.type === type) ||
        childrenOfType.length !== obj.children.length
      ) {
        leafArray.push(obj);
      }
    }

    return leafArray;
  }

  // Returns leafs of all children. Similar to the `classes` accessor, but returns children of any
  // type.
  childLeafs() {
    return this.children.map((child) => child.leafs()).flat();
  }

  visit(fn, stack = []) {
    stack.push(this);
    fn(this, stack);
    this.children.forEach((child) => child.visit(fn, stack));
    stack.pop();
  }

  buildId(tokens = []) {
    if (this.parent) {
      this.parent.buildId(tokens);

      let separator;
      switch (this.parent.type) {
        case CodeObjectType.PACKAGE:
          separator = '/';
          break;
        case CodeObjectType.CLASS:
          separator = '::';
          break;
        default:
          separator = '->';
      }
      tokens.push(separator);
    }
    tokens.push(this.name);
    return tokens;
  }

  classLocations(paths = new Set()) {
    this.children.forEach((child) => child.classLocations(paths));

    if (this.type === CodeObjectType.FUNCTION) {
      const tokens = this.data.location.split(':', 2);
      paths.add(tokens[0]);
    }
    return paths;
  }

  toJSON() {
    const obj = {
      name: this.data.name,
      type: this.data.type,
    };

    if (this.data.type === CodeObjectType.FUNCTION) {
      obj.static = this.data.static;
      obj.location = this.data.location;
    }
    if (this.data.type === CodeObjectType.QUERY) {
      obj.database_type = this.data.database_type;
    }

    if (this.children.length > 0) {
      obj.children = this.children;
    }

    return obj;
  }

  static constructDataChainFromEvent(event) {
    let elements;
    if (event.httpServerRequest) {
      elements = [
        {
          type: CodeObjectType.HTTP,
          name: 'HTTP server requests',
        },
        {
          type: CodeObjectType.ROUTE,
          name: event.route,
        },
      ];
    } else if (event.httpClientRequest) {
      let serviceName;

      try {
        const url = new URL(event.httpClientRequest.url);
        serviceName = url.host;
      } catch {
        serviceName = 'External service';
      }

      elements = [
        {
          type: CodeObjectType.EXTERNAL_SERVICE,
          name: serviceName,
        },
      ];
    } else if (event.sqlQuery) {
      elements = [
        {
          type: CodeObjectType.DATABASE,
          name: 'Database',
        },
        {
          type: CodeObjectType.QUERY,
          name: event.sqlQuery,
          database_type: event.sql.database_type,
        },
      ];
    } else {
      elements = [
        {
          type: CodeObjectType.CLASS,
          name: event.definedClass,
        },
        {
          type: CodeObjectType.FUNCTION,
          name: event.methodId,
          static: event.isStatic,
          location: '',
        },
      ];
    }

    // Flag this object as having been created dynamically
    const queue = [...elements];
    while (queue.length) {
      const obj = queue.pop();
      obj.dynamic = true;
      if (obj.children) {
        obj.children.forEach((child) => queue.push(child));
      }
    }

    return elements;
  }

  get inboundConnections() {
    return this.allEvents
      .filter((e) => e.parent)
      .map((e) => e.parent.codeObject);
  }

  get outboundConnections() {
    return this.allEvents
      .map((e) => e.children)
      .flat()
      .map((e) => e.codeObject);
  }

  get sqlQueries() {
    return this.allEvents
      .map((e) => e.children)
      .flat()
      .filter((e) => e.sql)
      .map((e) => e.codeObject);
  }

  get prettyName() {
    switch (this.type) {
      case CodeObjectType.FUNCTION:
        return `${this.classOf}${this.static ? '.' : '#'}${this.name}`;
      case CodeObjectType.CLASS:
        return this.classOf;
      case CodeObjectType.PACKAGE:
        return this.packageOf;
      case CodeObjectType.QUERY:
        return getSqlLabelFromString(this.name);
      default:
        return this.name;
    }
  }

  get fqid() {
    return `${this.type}:${this.id}`;
  }
}

function indexCodeObject(co, codeObjects, codeObjectsById) {
  codeObjects.push(co);
  codeObjectsById[co.id] = co;
}

class ClassMap {
  constructor(classMap) {
    this.codeObjectsByLocation = {};
    this.codeObjects = [];
    this.codeObjectsById = {};

    const buildCodeObject = (data, parent = null) => {
      const co = new CodeObject(data, parent);
      indexCodeObject(co, this.codeObjects, this.codeObjectsById);

      (data.children || []).forEach((child) => {
        buildCodeObject(child, co);
      });

      if (co.type !== 'package') {
        co.locations.forEach((location) => {
          let codeObjects = this.codeObjectsByLocation[location];
          if (!codeObjects) {
            codeObjects = [];
            this.codeObjectsByLocation[location] = codeObjects;
          }
          codeObjects.push(co);
        });
      }

      return co;
    };

    this.roots = classMap.map((root) => buildCodeObject(root));
  }

  visit(fn) {
    this.roots.forEach((co) => co.visit(fn));
  }

  search(query) {
    const queryLower = query.toLowerCase();
    return this.codeObjects.filter(
      (co) => co.id.toLowerCase().indexOf(queryLower) !== -1
    );
  }

  codeObjectFromId(id) {
    return this.codeObjectsById[id];
  }

  codeObjectsAtLocation(location) {
    return this.codeObjectsByLocation[location] || [];
  }

  codeObjectFromEvent(event) {
    let codeObject;
    // These types of events should not be reporting path and lineno, but sometimes
    // they do.
    if (!(event.httpServerRequest || event.httpClientRequest || event.sql)) {
      const { path, lineno } = event;
      const location = [path, lineno].filter((e) => e).join(':');
      if (location !== '') {
        const codeObjects = this.codeObjectsAtLocation(location);
        codeObject = codeObjects.find((o) => o.name === event.methodId);
        if (codeObject) {
          return codeObject;
        }
      }
    }

    return null;
  }

  // Returns the first root code object of a given type or null if it doesn't exist
  root(type) {
    return this.roots.find((obj) => obj.type === type);
  }

  // Returns the root HTTP code object if it exists
  get httpObject() {
    return this.root(CodeObjectType.HTTP);
  }

  // Returns the root SQL code object if it exists
  get sqlObject() {
    return this.root(CodeObjectType.DATABASE);
  }

  // Binds an event array to code objects and vice versa. This allows use of
  // direct accessors: `Event.codeObject` and `CodeObject.events`. Additionally,
  // it guarantees non-null accessors, meaning it will construct a code object
  // for an event if it previously did not exist.
  bindEvents(events) {
    if (!events || !Array.isArray(events) || !events.length) {
      return;
    }

    const validCodeObjects = new Set();
    events
      .filter((e) => e.isCall())
      .forEach((e) => {
        let codeObject = this.codeObjectFromEvent(e);
        if (!codeObject) {
          const findOrCreateCodeObject = (data, codeObjectArray, parent) => {
            // TODO: This ignores static/non-static function collisions and function overloads, though this method
            // is never currently called in a context where those edge cases exist.
            let newCodeObject = codeObjectArray.find(
              (obj) => obj.type === data.type && obj.name === data.name
            );

            if (!newCodeObject) {
              newCodeObject = new CodeObject(data, parent);
              if (!parent) {
                this.roots.push(newCodeObject);
              }
              indexCodeObject(
                newCodeObject,
                this.codeObjects,
                this.codeObjectsById
              );
            }

            return newCodeObject;
          };

          const dataElements = CodeObject.constructDataChainFromEvent(e);
          let parent = null;
          dataElements.forEach((dataElement) => {
            parent = findOrCreateCodeObject(
              dataElement,
              parent ? parent.children : this.roots,
              parent
            );
          });
          codeObject = parent;
        }

        e.codeObject = codeObject;
        codeObject.events.push(e);

        const ancestors = codeObject.ancestors();
        validCodeObjects.add(codeObject);
        ancestors.forEach((obj) => validCodeObjects.add(obj));
      });

    this.codeObjects = this.codeObjects.filter((obj) =>
      validCodeObjects.has(obj)
    );

    this.roots = this.roots.filter((obj) => validCodeObjects.has(obj));

    Object.keys(this.codeObjectsByLocation).forEach((obj) => {
      if (!validCodeObjects.has(obj)) {
        delete this.codeObjectsByLocation[obj];
      }
    });

    Object.entries(this.codeObjectsById).forEach(([id, obj]) => {
      if (!validCodeObjects.has(obj)) {
        delete this.codeObjectsById[id];
      }
    });
  }

  toJSON() {
    // Don't write out code objects that were created during runtime
    return this.roots.filter((obj) => !obj.dynamic);
  }
}

// Deprecated. Prefer `Event` instead.
class CallNode {
  constructor(input = {}, output = {}, caller = null, labels = []) {
    this.input = input;
    this.output = output;
    this.children = [];
    this.labels = labels;

    // Cyclic references shall not be enumerable
    addHiddenProperty(this, 'caller', { value: caller });
  }

  get caller() {
    return this.$hidden.caller;
  }

  set caller(value) {
    this.$hidden.$hiddencaller = value;
  }

  clone() {
    const input = { ...this.input };
    const output = { ...this.output };
    const labels = [...this.labels];
    const newNode = new CallNode(input, output, null, labels);

    if (this.displayName) {
      newNode.displayName = this.displayName;
    }

    this.children.forEach((child) => {
      const newChild = child.clone();
      newNode.addChild(newChild);
      newChild.caller = newNode;
    });

    return newNode;
  }

  addChild(node) {
    this.children.push(node);
  }

  // Replace a given child with a different set of children.
  replaceChild(child, children) {
    const idx = this.children.indexOf(child);
    if (idx === -1) {
      throw new Error(`${child} not found in call tree`);
    }

    this.children.splice(idx, 1, ...children);
    /* eslint-disable no-param-reassign */
    children.forEach((c) => {
      c.caller = this;
    });
    child.caller = null;
    /* eslint-enable no-param-reassign */
  }

  removeChild(child) {
    const childIndex = this.children.indexOf(child);
    if (childIndex < 0) {
      throw new Error(`${child} found orphaned by ${this} !`);
    }
    this.children.splice(childIndex, 1);
  }

  postOrderForEach(fn, stack = []) {
    stack.push(this);
    const children = [...this.children];
    children.forEach((child) => child.postOrderForEach(fn, stack));
    fn(this, stack);
    stack.pop(this);
  }

  preOrderForEach(fn, stack = []) {
    stack.push(this);
    fn(this, stack);
    const children = [...this.children];
    children.forEach((child) => child.preOrderForEach(fn, stack));
    stack.pop(this);
  }

  forEach(fn) {
    this.postOrderForEach(fn);
  }

  // filter returns a tree in which all nodes match a condition. If a node fails the
  // condition, its children are adopted by it's parent.
  filter(conditionFn) {
    const root = this.clone();
    root.forEach((node, stack) => {
      if (node.isRoot()) {
        return;
      }

      if (!conditionFn(node, stack)) {
        const parent = node.caller;
        parent.replaceChild(node, node.children);
      }
    });

    return root;
  }

  // include returns a tree in which all leaf nodes match a condition.
  // If a node passes the condition, the node and all of its parents are retained
  // in the tree. If it fails, the node and its children are removed from the tree.
  // Note that if a node passes the condition, the condition will not be evaluated
  // for that node's parent nodes, since they are already marked as retained.
  include(conditionFn) {
    /* eslint-disable no-param-reassign */
    const root = this.clone();
    root.postOrderForEach((node, stack) => {
      if (node.isRoot()) {
        return;
      }

      if (node.marked_include && node.caller) {
        node.caller.marked_include = true;
        return;
      }

      node.marked_include = conditionFn(node, stack);
      if (node.marked_include) {
        if (node.caller) {
          node.caller.marked_include = true;
        }
        return;
      }

      if (node.caller) {
        node.caller.removeChild(node);
      }
    });

    root.postOrderForEach((node) => {
      delete node.marked_include;
    });

    return root;
    /* eslint-enable no-param-reassign */
  }

  // exclude returns a tree in which all nodes that match a condition are removed, along
  // with their child nodes.
  exclude(conditionFn) {
    const root = this.clone();
    root.forEach((node, stack) => {
      if (node.isRoot()) {
        return;
      }

      if (conditionFn(node, stack)) {
        const parent = node.caller;
        parent.removeChild(node);
      }
    });

    return root;
  }

  // toArray returns this tree as a one dimensional array
  toArray() {
    const childEvents = this.children.map((child) => child.toArray()).flat();

    if (this.isRoot()) {
      return childEvents;
    }

    return [this, ...childEvents];
  }

  // find calls find recursively on all children
  // iterates in pre-order
  find(fn) {
    if (fn(this)) {
      return this;
    }

    for (let i = 0; i < this.children.length; i += 1) {
      const match = this.children[i].find(fn);
      if (match) {
        return match;
      }
    }

    return null;
  }

  // depth returns the depth of this node
  depth() {
    return this.ancestors().length;
  }

  // ancestors returns an array of this nodes ancestors
  ancestors() {
    const nodes = [];

    let parent = this.caller;
    while (parent) {
      nodes.push(parent);
      parent = parent.caller;
    }

    return nodes;
  }

  // returns whether or not a node has a particular node in its ancestry
  hasAncestor(ancestor) {
    let node = this;
    while (node) {
      if (node === ancestor) {
        return true;
      }
      node = node.caller;
    }
    return false;
  }

  descendants() {
    return [this, ...this.children.map((x) => x.descendants()).flat()];
  }

  next() {
    if (this.children.length > 0) {
      return this.children[0];
    }

    let child = this;
    let parent = this.caller;
    const fnChildIndex = (n) => n === child;
    while (parent) {
      const myIndex = parent.children.findIndex(fnChildIndex);
      if (myIndex < 0) {
        throw new Error(`${this} found orphaned by ${parent}!`);
      }

      if (myIndex < parent.children.length - 1) {
        return parent.children[myIndex + 1];
      }

      child = parent;
      parent = parent.caller;
    }

    return null;
  }

  previous() {
    const parent = this.caller;
    if (!parent) {
      return null;
    }

    if (parent.children.length === 1) {
      return parent;
    }

    const myIndex = parent.children.findIndex((n) => n === this);
    if (myIndex < 0) {
      throw new Error(`${this.input.id} found orphaned by ${parent.input.id}!`);
    }

    if (myIndex > 0) {
      // this branch will yield our previous node
      let candidate = parent.children[myIndex - 1];

      // iterate until we find a leaf node
      while (candidate.children.length > 0) {
        candidate = candidate.children[candidate.children.length - 1];
      }

      return candidate;
    }

    return parent;
  }

  // return the node to the left, at given max depth
  left(depth) {
    const target = depth || this.depth();

    // find the target or the nearest descendant
    let current = this;
    for (;;) {
      const parent = current.caller;
      if (!parent) return this;

      const siblings = parent.children;
      const i = siblings.indexOf(current);
      if (i !== 0) {
        current = parent.children[i - 1];
        break;
      } else {
        current = parent;
      }
    }

    // find rightmost child closest to the right depth
    while (current.depth() !== target) {
      const { children } = current;
      if (children.length === 0) break;
      current = children[children.length - 1];
    }

    return current;
  }

  // return the node to the right, at given max depth
  right(depth) {
    const target = depth || this.depth();

    // find the target or the nearest descendant
    let current = this;
    for (;;) {
      const parent = current.caller;
      if (!parent) return this;

      const siblings = parent.children;
      const i = siblings.indexOf(current);
      if (i !== siblings.length - 1) {
        current = parent.children[i + 1];
        break;
      } else {
        current = parent;
      }
    }

    // find leftmost child closest to the right depth
    while (current.depth() !== target) {
      const { children } = current;
      if (children.length === 0) break;
      [current] = children;
    }

    return current;
  }

  isRoot() {
    return this.caller === null;
  }

  count() {
    let numNodes = 0;
    this.forEach(() => {
      numNodes += 1;
    });
    return numNodes;
  }

  get id() {
    if (this.input && this.input.id) {
      return this.input.id;
    }
    return null;
  }
}

function getListenerArray(eventSource, eventType) {
  /* eslint-disable no-param-reassign */
  let listeners = eventSource.listeners[eventType];
  if (!listeners) {
    listeners = [];
    eventSource.listeners[eventType] = listeners;
  }
  return listeners;
  /* eslint-enable no-param-reassign */
}

class EventSource {
  constructor() {
    this.listeners = {};
    this.anyListeners = [];
  }

  once(eventType, fn) {
    const handlers = getListenerArray(this, eventType);
    handlers.push({ fn, once: true });
    return this;
  }

  on(eventType, fn) {
    const handlers = getListenerArray(this, eventType);
    handlers.push({ fn });
    return this;
  }

  off(eventType, fn) {
    const handlers = this.listeners[eventType];

    if (handlers) {
      const updatedHandlers = handlers.filter((h) => h.fn && h.fn !== fn);
      if (updatedHandlers.length === 0) {
        delete this.listeners[eventType];
      } else if (updatedHandlers.length !== handlers.length) {
        this.listeners[eventType] = updatedHandlers;
      }
    }

    return this;
  }

  emit(eventType, data = undefined) {
    const handlers = this.listeners[eventType];

    if (handlers) {
      let includesOnce = false;
      handlers.forEach((handler) => {
        if (handler.once) {
          includesOnce = true;
        }

        try {
          handler.fn(data);
        } catch (e) {
          console.error(`error occurred while executing event ${eventType}`);
          console.error(e);
        }
      });

      if (includesOnce) {
        // Only reassign this value if we've encountered a handler that's run once
        this.listeners[eventType] = this.listeners[eventType].filter(
          (h) => !h.once
        );
      }
    }

    this.anyListeners.forEach((eventSource) =>
      eventSource.emit(eventType, data)
    );

    return this;
  }

  // Pipe events from EventSource A to EventSource B. If `eventTypes` are
  // provided, bind only those types. Otherwise, pipe any event.
  pipe(eventSource, ...eventTypes) {
    if (eventTypes.length) {
      eventTypes.forEach((type) =>
        eventSource.on(type, (data) => this.emit(data))
      );
      return this;
    }

    eventSource.any(this);
    return this;
  }

  // Bind `eventSource` to recieve any event sent from `this`.
  any(eventSource) {
    this.anyListeners.push(eventSource);
    return this;
  }
}

class CallTree extends EventSource {
  constructor(events, functionLabels = () => []) {
    super();

    this.dataStore = {
      rootEvent: this.rootNode,
      selectedEvent: this.rootNode,
    };

    this.rootEvent = new CallNode();
    const stack = [this.rootEvent];
    events.forEach((e) => {
      if (e.event !== 'call') {
        if (stack.length > 1) {
          stack.pop();
        }
        return;
      }

      const parent = stack[stack.length - 1];
      const callNode = new CallNode(
        e,
        e.returnEvent,
        parent,
        functionLabels(e)
      );
      parent.addChild(callNode);
      stack.push(callNode);
    });

    return this;
  }

  get rootEvent() {
    return this.dataStore.rootEvent;
  }

  set rootEvent(event) {
    this.dataStore.rootEvent = event;
    this.emit('rootEvent', event);
  }

  get selectedEvent() {
    return this.dataStore.selectedEvent;
  }

  set selectedEvent(event) {
    this.dataStore.selectedEvent = event;
    this.emit('selectedEvent', event);
  }
}

// merge contiguous changes into a single element (as an array)
function groupChanges(eventArray) {
  const events = new Set(eventArray);
  const seen = new Set();
  const result = [];

  eventArray.forEach((e) => {
    if (seen.has(e)) {
      return;
    }

    seen.add(e);

    const group = [e];
    let currentEvent = e;
    for (;;) {
      const { nextSibling } = currentEvent;
      if (nextSibling && events.has(nextSibling)) {
        group.push(nextSibling);
        seen.add(nextSibling);
        currentEvent = nextSibling;
      } else {
        break;
      }
    }

    result.push(group);
  });

  return result;
}

class AppMap {
  constructor(data) {
    this.data = {
      events: [],
      classMap: [],
      ...data,
    };

    this.classMap = new ClassMap(this.data.classMap);
    this.callTree = new CallTree(this.events);
    this.classMap.bindEvents(this.events);
    this.labels = buildLabels(this.classMap, this.events);

    // Establish event linked list references
    let previousEvent;
    this.events.forEach((e) => {
      if (previousEvent) {
        e.previous = previousEvent;
        previousEvent.next = e;
      }

      previousEvent = e;
    });

    // Keep these fields seperate for serialization
    delete this.data.classMap;
  }

  get version() {
    return this.data.version;
  }

  get metadata() {
    return this.data.metadata || {};
  }

  get name() {
    return this.metadata.name;
  }

  get rootEvent() {
    return this.callTree.rootEvent;
  }

  get events() {
    return this.data.events;
  }

  shallowCopy() {
    const copy = new AppMap({});
    copy.data.events = this.data.events;
    copy.data.metadata = this.data.metadata;
    copy.classMap = this.classMap;
    copy.callTree = this.callTree;
    return copy;
  }

  // Retrieve an array of root entry point events (currently, just HTTP server requests). If none
  // are found, return all the root nodes which have no caller.
  rootEvents() {
    return getRootEvents(this.events);
  }

  // Iterate many AppMaps at once as an event tree. This method will follow the deepest branch
  // available, and yield the nodes at that position. Given that the tree structure may differ
  // across AppMaps, it's possible that some nodes will be null.
  static *multiTreeIterator(baseAppMap, workingAppMap) {
    let baseEvent;
    let workingEvent;
    const baseQueue = baseAppMap.rootEvents();
    const workingQueue = workingAppMap.rootEvents();

    resolveDifferences(baseQueue, workingQueue);

    for (;;) {
      baseEvent = baseQueue.shift();
      workingEvent = workingQueue.shift();

      // If both are null, every path has been exhausted. We're done.
      if (!baseEvent && !workingEvent) {
        return;
      }

      // Don't bother continuing to iterate through a branch that doesn't exist in the other tree.
      if (baseEvent && workingEvent) {
        const baseChildren = baseEvent ? [...baseEvent.children] : [];
        const workingChildren = workingEvent ? [...workingEvent.children] : [];

        resolveDifferences(baseChildren, workingChildren);
        baseChildren.forEach((e) => baseQueue.push(e));
        workingChildren.forEach((e) => workingQueue.push(e));
      }

      yield [baseEvent, workingEvent];
    }
  }

  static getDiff(baseAppMap, workingAppMap) {
    const changeSummary = {
      changed: [],
      added: [],
      removed: [],
    };

    const iter = AppMap.multiTreeIterator(baseAppMap, workingAppMap);
    let result = iter.next();
    while (!result.done) {
      const [nodeBase, nodeWorking] = result.value;

      if (!nodeBase) {
        changeSummary.added.push(nodeWorking);
      } else if (!nodeWorking) {
        changeSummary.removed.push(nodeBase);
      } else if (nodeBase.hash !== nodeWorking.hash) {
        changeSummary.changed.push([nodeBase, nodeWorking]);
      }

      result = iter.next();
    }

    changeSummary.added = groupChanges(changeSummary.added);
    changeSummary.removed = groupChanges(changeSummary.removed);

    return changeSummary;
  }

  toJSON() {
    return {
      ...this.data,
      classMap: this.classMap,
    };
  }
}

// This class supercedes `CallTree` and `CallNode`. Events are stored in a flat
// array and can also be traversed like a tree via `parent` and `children`.
class Event {
  constructor(obj) {
    let data = obj;

    if (obj instanceof Event) {
      data = { ...obj };

      if (obj.$hidden.parameters) {
        data.parameters = obj.$hidden.parameters.map((p) => ({ ...p }));
      }

      if (Array.isArray(obj.$hidden.message)) {
        data.message = obj.$hidden.message.map((m) => ({ ...m }));
      }

      if (obj.$hidden.labels) {
        data.labels = [...obj.$hidden.labels];
      }

      if (obj.$hidden.exceptions) {
        data.exceptions = [...obj.$hidden.exceptions];
      }
    }

    // Cyclic references shall not be enumerable
    if (data.event === 'call') {
      addHiddenProperty(this, 'parent');
      addHiddenProperty(this, 'children', { writable: false, value: [] });
      addHiddenProperty(this, 'dataReferences', { writable: false, value: [] });
      addHiddenProperty(this, 'codeObject');
      addHiddenProperty(this, 'parameters');
      addHiddenProperty(this, 'message');
    }

    addHiddenProperty(this, 'linkedEvent');
    addHiddenProperty(this, 'labels');
    addHiddenProperty(this, 'exceptions');
    addHiddenProperty(this, 'next');
    addHiddenProperty(this, 'previous');
    addHiddenProperty(this, 'hash');
    addHiddenProperty(this, 'identityHash');
    addHiddenProperty(this, 'depth');

    // Data must be written last, after our properties are configured.
    Object.assign(this, data);
  }

  get depth() {
    if (this.$hidden.depth === undefined) {
      let result = 0;
      let { parent } = this;
      while (parent) {
        result += 1;
        parent = parent.parent;
      }
      this.$hidden.depth = result;
    }
    return this.$hidden.depth;
  }

  get methodId() {
    return this.method_id;
  }

  get isFunction() {
    return this.definedClass && this.methodId;
  }

  get isStatic() {
    return this.static;
  }

  get sql() {
    return this.callEvent.sql_query;
  }

  get returnValue() {
    return this.returnEvent.return_value;
  }

  get elapsedTime() {
    return this.returnEvent.elapsed;
  }

  get linkedEvent() {
    return this.$hidden.linkedEvent;
  }

  get next() {
    return this.$hidden.next;
  }

  get previous() {
    return this.$hidden.previous;
  }

  get parent() {
    return this.$hidden.parent;
  }

  get children() {
    return this.$hidden.children || [];
  }

  get codeObject() {
    return this.callEvent.$hidden.codeObject;
  }

  get parameters() {
    return this.callEvent.$hidden.parameters;
  }

  get labels() {
    const eventLabels = this.callEvent.$hidden.labels || [];
    return new Set([...eventLabels, ...this.callEvent.codeObject.labels]);
  }

  get exceptions() {
    return this.returnEvent.$hidden.exceptions || [];
  }

  get message() {
    return this.callEvent.$hidden.message;
  }

  get httpServerRequest() {
    return this.callEvent.http_server_request;
  }

  get httpServerResponse() {
    return this.returnEvent.http_server_response;
  }

  get httpClientRequest() {
    return this.callEvent.http_client_request;
  }

  get httpClientResponse() {
    return this.returnEvent.http_client_response;
  }

  get definedClass() {
    return this.defined_class ? this.defined_class.replace(/\./g, '/') : null;
  }

  get requestPath() {
    if (this.httpServerRequest) {
      return (
        this.httpServerRequest.normalized_path_info ||
        this.httpServerRequest.path_info
      );
    }
    if (this.httpClientRequest) {
      return this.httpClientRequest.url;
    }
    return null;
  }

  get requestMethod() {
    if (this.httpServerRequest) {
      return this.httpServerRequest.request_method;
    }
    if (this.httpClientRequest) {
      return this.httpClientRequest.request_method;
    }
    return null;
  }

  get route() {
    const { requestMethod, requestPath } = this;
    if (!requestMethod || !requestPath) {
      return null;
    }

    return `${requestMethod} ${requestPath}`;
  }

  get sqlQuery() {
    const { sql } = this;
    if (!sql) {
      return null;
    }
    return sql.normalized_sql || sql.sql;
  }

  get fqid() {
    return `event:${this.id}`;
  }

  get previousSibling() {
    const { parent } = this;
    if (!parent) {
      return null;
    }

    const myIndex = parent.children.findIndex((e) => e === this);
    console.assert(
      myIndex !== -1,
      'attempted to locate index of an orphaned event'
    );

    if (myIndex === 0) {
      return null;
    }

    return parent.children[myIndex - 1];
  }

  get nextSibling() {
    const { parent } = this;

    if (!parent) {
      let event = this.next;

      // Get the next root level event
      while (event) {
        if (event.isCall() && !event.parent) {
          return event;
        }

        event = event.next;
      }

      return null;
    }

    const myIndex = this.parent.children.findIndex((e) => e === this);
    console.assert(
      myIndex !== -1,
      'attempted to locate index of an orphaned event'
    );

    if (myIndex === parent.children.length - 1) {
      return null;
    }

    return parent.children[myIndex + 1];
  }

  set codeObject(value) {
    if (hasProp(this.$hidden, 'codeObject')) {
      this.$hidden.codeObject = value;
    }
  }

  set parameters(value) {
    if (hasProp(this.$hidden, 'parameters')) {
      this.$hidden.parameters = value;
    }
  }

  set labels(value) {
    if (hasProp(this.$hidden, 'labels')) {
      this.$hidden.labels = value;
    }
  }

  set exceptions(value) {
    if (hasProp(this.$hidden, 'exceptions')) {
      this.$hidden.exceptions = value;
    }
  }

  set message(value) {
    if (hasProp(this.$hidden, 'message')) {
      this.$hidden.message = value;
    }
  }

  set linkedEvent(value) {
    this.$hidden.linkedEvent = value;
  }

  set next(value) {
    this.$hidden.next = value;
  }

  set previous(value) {
    this.$hidden.previous = value;
  }

  set parent(value) {
    this.$hidden.parent = value;
  }

  link(event) {
    /* eslint-disable no-param-reassign */
    if (event.linkedEvent || this.linkedEvent) {
      return;
    }

    event.linkedEvent = this;
    this.linkedEvent = event;
    /* eslint-enable no-param-reassign */
  }

  isCall() {
    return this.event === 'call';
  }

  isReturn() {
    return this.event === 'return';
  }

  get callEvent() {
    return this.isCall() ? this : this.$hidden.linkedEvent;
  }

  get returnEvent() {
    return this.isReturn() ? this : this.$hidden.linkedEvent;
  }

  get hash() {
    if (!this.$hidden.hash) {
      this.$hidden.hash = hashEvent(this);
    }
    return this.$hidden.hash;
  }

  get identityHash() {
    if (!this.$hidden.identityHash) {
      this.$hidden.identityHash = identityHashEvent(this);
    }
    return this.$hidden.identityHash;
  }

  callStack() {
    const stack = this.ancestors().reverse();
    stack.push(this.callEvent);
    return stack;
  }

  ancestors() {
    const ancestorArray = [];
    let event = this.callEvent.parent;

    while (event) {
      ancestorArray.push(event);
      event = event.parent;
    }

    return ancestorArray;
  }

  descendants() {
    const descendantArray = [];
    const queue = [...this.children];

    while (queue.length) {
      const event = queue.pop();
      event.children.forEach((child) => queue.push(child));
      descendantArray.push(event);
    }

    return descendantArray;
  }

  traverse(fn) {
    let event = this;
    const boundaryEvent = this.nextSibling;
    let { onEnter } = fn;
    let { onExit } = fn;

    if (typeof fn === 'function') {
      onEnter = fn;
      onExit = fn;
    }

    while (event) {
      if (event.isCall() && onEnter) {
        onEnter(event);
      } else if (event.isReturn() && onExit) {
        onExit(event);
      }

      event = event.next;
      if (!event || event === boundaryEvent) {
        break;
      }
    }
  }

  dataObjects() {
    return [this.parameters, this.message, this.returnValue]
      .flat()
      .filter(Boolean);
  }

  toString() {
    const { sqlQuery } = this;
    if (sqlQuery) {
      return sqlQuery;
    }

    const { route } = this;
    if (route) {
      return route;
    }

    const { definedClass, isStatic, methodId } = this;
    return `${definedClass}${isStatic ? '.' : '#'}${methodId}`;
  }
}

class EventStack {
  constructor(id) {
    this.events = [];
    this.stack = [];
    this.id = id;
    this.eventMap = {};
  }

  add(event) {
    // Don't begin a stack with a return, we likely started recording in the
    // middle of thread execution.
    if (event.isReturn() && this.events.length === 0) {
      return;
    }

    if (event.isCall()) {
      this.stack.push(event);
      this.eventMap[event.id] = event;
    } else {
      if (typeof event.parent_id === 'undefined') {
        const lastEvent = this.stack[this.stack.length - 1];
        if (
          lastEvent &&
          lastEvent.defined_class === event.defined_class &&
          lastEvent.method_id === event.method_id &&
          lastEvent.path === event.path &&
          lastEvent.static === event.static
        ) {
          event.parent_id = lastEvent.id; // eslint-disable-line no-param-reassign
        } else {
          // An event has returned but the last call in the stack was not its
          // caller. There's not really anything we can do to rectify this, so
          // the event will be discarded.
          return;
        }
      }

      const call = this.eventMap[event.parent_id];
      if (call) {
        call.link(event);
        this.stack.pop();

        const parent = this.stack[this.stack.length - 1];
        if (parent) {
          parent.children.push(call);
          call.parent = parent;
        }
      } else {
        throw new Error(
          `return #${event.id} is missing call #${event.parent_id}`
        );
      }
    }

    this.events.push(event);
  }

  unwound() {
    return this.events.length > 0 && this.stack.length === 0;
  }
}

function getStackId(collection) {
  return (
    Object.keys(collection.activeStacks).length +
    collection.finalizedStacks.length
  );
}

// EventSorter is responsible for untangling an event array. It sorts events by
// thread execution order and drops leading return statements.
class EventSorter {
  constructor() {
    this.activeStacks = {};
    this.finalizedStacks = [];
  }

  // Add an event to be sorted. An event must be added through this method to
  // be collected.
  add(event) {
    let stack = this.activeStacks[event.thread_id];
    if (!stack) {
      const id = getStackId(this);
      stack = new EventStack(id);
      this.activeStacks[event.thread_id] = stack;
    }

    stack.add(event);

    if (stack.unwound()) {
      this.finalizedStacks.splice(stack.id, 0, stack.events);
      delete this.activeStacks[event.thread_id];
    }
  }

  // Calculate the serialized size of all events. This is more of an
  // approximation than an exact number.
  size() {
    let size = sizeof(Object.values(this.activeStacks));
    size += sizeof(this.finalizedStacks);
    return size;
  }

  // Returns an array of "chunks". A chunk is an array consisting of many
  // stacks. A stack is an array consisting of many events.
  collect() {
    // Join active and finalized stacks. We want to make sure we iterate over
    // every event.
    const stacks = [...this.finalizedStacks];
    Object.values(this.activeStacks).forEach((s) =>
      stacks.splice(s.id, 0, s.events)
    );

    return stacks.reduce((chunks, stack) => {
      if (stack.length === 0) {
        return chunks;
      }

      // We're the first chunk in, meaning we don't need to worry about any
      // chunks behind us. Just push it.
      if (chunks.length === 0) {
        chunks.push([stack]);
        return chunks;
      }

      // If the root event is an HTTP request, this a complete chunk. Push it.
      if (stack[0].http_server_request) {
        chunks.push([stack]);
        return chunks;
      }

      if (stack[0].http_client_request) {
        chunks.push([stack]);
        return chunks;
      }

      // Check to see if the previous chunk began with an HTTP request. If it
      // does, push a new chunk. Otherwise, append to the last chunk.
      const prevChunk = chunks[chunks.length - 1];
      const prevStack = prevChunk[prevChunk.length - 1];
      if (
        prevStack[0].http_server_request ||
        prevStack[0].http_client_request
      ) {
        chunks.push([stack]);
      } else {
        prevChunk.push(stack);
      }

      return chunks;
    }, []);
  }
}

function eventName(classMap, e) {
  const { callEvent } = e;
  const obj = classMap.codeObjectFromEvent(callEvent);
  if (obj) {
    return obj.id;
  }

  return `${callEvent.defined_class}${callEvent.static ? '.' : '#'}${
    callEvent.method_id
  }`;
}

// Performs an array of transform functions on an object. The transform function
// is expected to return the transformed object.
const transform = (transforms, obj, ...args) =>
  transforms.reduce((x, fn) => fn(x, ...args), obj);

// AppMapBuilder is responsible for transforming appmap data before returning
// an AppMap model.
class AppMapBuilder extends EventSource {
  constructor(data) {
    super();

    this.sorter = new EventSorter();
    this.transforms = {
      event: [],
      stack: [],
      chunk: [],
    };

    if (data) {
      this.source(data);
    }
  }

  // Provide a source of data - i.e. an appmap JSON object
  source(data) {
    const dataType = typeof data;
    if (dataType === 'object') {
      this.data = { ...data };
    } else if (dataType === 'string') {
      this.data = JSON.parse(data);
    } else {
      throw new Error(
        `got invalid type ${dataType}, expected object or string`
      );
    }

    (this.data.events || [])
      .map((e) => new Event(e))
      .forEach((e) => this.sorter.add(e));

    delete this.data.events;

    return this;
  }

  // register an optional event transform
  event(fn) {
    console.assert(typeof fn === 'function');
    this.transforms.event.push(fn);
    return this;
  }

  // register a optional stack transform
  stack(fn) {
    console.assert(typeof fn === 'function');
    this.transforms.stack.push(fn);
    return this;
  }

  // register a optional chunk transform
  chunk(fn) {
    console.assert(typeof fn === 'function');
    this.transforms.chunk.push(fn);
    return this;
  }

  // normalize the appmap data before returning an Appmap model
  normalize() {
    // Re-index events
    let eventId = 1;
    this.event((event) => {
      /* eslint-disable no-param-reassign */
      event.id = eventId;
      eventId += 1;

      if (event.isCall() && event.returnEvent) {
        event.returnEvent.parent_id = event.id;
      }

      // Normalize status/status_code properties
      const { httpServerResponse, httpClientResponse } = event;
      if (event.isReturn()) {
        if (httpServerResponse && httpServerResponse.status_code) {
          httpServerResponse.status = httpServerResponse.status_code;
          delete httpServerResponse.status_code;
        }
        if (httpClientResponse && httpClientResponse.status_code) {
          httpClientResponse.status = httpClientResponse.status_code;
          delete httpClientResponse.status_code;
        }
      }

      return event;
      /* eslint-enable no-param-reassign */
    });

    // Balance the stack by adding dummy returns to calls which never return
    return this.stack((events) => {
      events
        .filter((e) => e.isCall() && !e.returnEvent)
        .reverse()
        .map((e) => {
          const returnEvent = new Event({
            event: 'return',
            thread_id: e.thread_id,
            parent_id: e.id,
          });
          returnEvent.link(e);
          return returnEvent;
        })
        .forEach((e) => events.push(e));

      return events;
    });
  }

  // Cut down the size of the event array before creating the Appmap model
  prune(sizeBytes) {
    console.assert(typeof sizeBytes === 'number');

    let classMap;
    let pruneRatio = 0;
    return this.on('preprocess', (d) => {
      classMap = new ClassMap(d.data.classMap);
      pruneRatio = Math.min(sizeBytes / d.size, 1);
    }).chunk((stacks) => {
      // We're storing size/count state in the global class map. This isn't
      // great but it works for now. Reset the counts for each chunk.
      classMap.visit((obj) => {
        /* eslint-disable no-param-reassign */
        obj.size = 0;
        obj.count = 0;
        /* eslint-enable no-param-reassign */
      });

      // Iterate each event, regardless of the stack
      stacks.flat(2).forEach((e) => {
        if (
          e.event !== 'call' ||
          e.sql_query ||
          e.http_server_request ||
          e.http_client_request
        ) {
          return;
        }

        const obj = classMap.codeObjectFromEvent(e);
        if (obj) {
          const objSize = sizeof(e);
          obj.size = obj.size + objSize || objSize;
          obj.count = obj.count + 1 || 1;
        }
      });

      // Build an array of code objects sorted by size. The largest object
      // will always be index 0.
      let totalBytes = 0;
      const eventAggregates = classMap.codeObjects
        .filter((obj) => obj.size)
        .sort((a, b) => a.size - b.size)
        .map((obj) => {
          totalBytes += obj.size;
          return {
            id: obj.id,
            count: obj.count,
            size: obj.size,
            totalBytes,
          };
        })
        .reverse();

      // Build a list of unique exclusions, starting with the largest event
      // type. Iterate until the estimated event array size is under our
      // threshold.
      const exclusions = new Set();
      for (let i = 0; i < eventAggregates.length; i += 1) {
        const eventInfo = eventAggregates[i];
        if (eventInfo.totalBytes <= totalBytes * pruneRatio) {
          break;
        }
        exclusions.add(eventInfo.id);
      }

      return stacks.map((events) =>
        events.filter((e) => {
          const { callEvent } = e;

          // If there's no call event, there's no need to retain this event
          if (!callEvent) {
            return false;
          }

          if (
            callEvent.http_server_request ||
            callEvent.http_client_request ||
            callEvent.sql_query
          ) {
            return true;
          }

          const name = eventName(classMap, e);
          return !exclusions.has(name);
        })
      );
    });
  }

  removeNoise() {
    if (!this.data.events) {
      return this;
    }

    const hasHttp = Boolean(
      this.data.events.find((e) => e.httpServerRequest || e.httpClientRequest)
    );
    if (!hasHttp) {
      // the entire file is noise - do nothing
      return this;
    }

    return this.chunk((stacks) =>
      stacks.filter((stack) => {
        if (!stack.length) {
          return false;
        }

        return (
          Boolean(stack[0].httpServerRequest) ||
          Boolean(stack[0].httpClientRequest)
        );
      })
    );
  }

  collectEvents() {
    return this.sorter
      .collect()
      .map((chunk) => {
        const transformedChunk = transform(this.transforms.chunk, chunk);
        return transformedChunk.map((stack) => {
          const transformedStack = transform(this.transforms.stack, stack);
          return transformedStack.map((event) =>
            transform(this.transforms.event, event)
          );
        });
      })
      .flat(2);
  }

  // Returns an Appmap model after running transforms such as normalize, prune,
  // etc.
  build() {
    const size = this.sorter.size();
    this.emit('preprocess', { size, data: this.data });
    return new AppMap({ ...this.data, events: this.collectEvents() });
  }
}

function buildAppMap(data = null) {
  return new AppMapBuilder(data);
}

class EventNavigator {
  constructor(event) {
    this.event = event;
  }

  get callEvent() {
    return this.event.callEvent;
  }

  get labels() {
    const { codeObject } = this.event;
    if (codeObject && codeObject.labels) {
      return codeObject.labels;
    }
    return null;
  }

  *self() {
    yield this;
  }

  *ancestors() {
    let event = this.callEvent.parent;

    while (event) {
      yield new EventNavigator(event);
      event = event.parent;
    }
  }

  /**
   * Generates all events which precede this event in the scenario.
   */
  *preceding() {
    const ancestors = this.ancestors();
    let ancestor = ancestors.next();
    while (!ancestor.done) {
      yield new EventNavigator(ancestor.value);
      let precedingSibling = this.precedingSiblings.next();
      while (!precedingSibling.done) {
        yield new EventNavigator(precedingSibling.value);
        const descendants = precedingSibling.value.descendants();
        let descendant = descendants.next();
        while (!descendant.done) {
          yield new EventNavigator(descendant.value);
          descendant = descendants.next();
        }
        precedingSibling = this.precedingSiblings.next();
      }
      ancestor = ancestors.next();
    }
  }

  *precedingSiblings() {
    const { parent } = this.callEvent;
    if (!parent) {
      return;
    }

    const index = parent.children.indexOf(this.callEvent);
    for (let i = index - 1; i >= 0; i -= 1) {
      yield new EventNavigator(parent.children[i]);
    }
  }

  *followingSiblings() {
    const { parent } = this.callEvent;
    if (!parent) {
      return;
    }

    const index = parent.children.indexOf(this.callEvent);
    for (let i = index + 1; i < parent.children.length; i += 1) {
      yield new EventNavigator(parent.children[i]);
    }
  }

  *descendants(filterFn = () => true) {
    function* traverseChildren(/** @type {Event[]} */ children) {
      if (!children || children.length === 0) {
        return;
      }
      for (let i = 0; i < children.length; i += 1) {
        const event = children[i];
        if (filterFn(event)) {
          yield new EventNavigator(event);
          yield* traverseChildren(event.children);
        }
      }
    }
    yield* traverseChildren(this.event.children);
  }

  hasLabel(label) {
    return this.hasLabels([label]);
  }

  hasLabels(...searchLabels) {
    if (!this.labels) {
      return false;
    }

    if (!searchLabels || !searchLabels.length) {
      return this.labels.size > 0;
    }

    return (
      searchLabels.filter((l) => this.labels.has(l)).length ===
      searchLabels.length
    );
  }
}

function mapFunctionLocations(memo, obj) {
  /* eslint-disable no-param-reassign */
  if (obj.type === 'function') {
    memo[obj.location] = obj;
  }

  if (obj.children) {
    obj.children.reduce(mapFunctionLocations, memo);
  }

  return memo;
  /* eslint-enable no-param-reassign */
}

class EventInfo {
  constructor(classMap) {
    this.functionObjects = classMap.reduce(mapFunctionLocations, {});
  }

  getName(event) {
    const label = getLabel(event);
    if (label) {
      return label;
    }

    const codeObj = this.getCodeObject(event);
    if (codeObj) {
      return codeObj.display_name;
    }

    // Fallback algorithm
    const separator = event.static ? '.' : '#';
    return [event.defined_class, separator, event.method_id].join('');
  }

  getLabels(event) {
    const labels = [];

    if (event.labels) {
      labels.push(...event.labels);
    }

    const codeObj = this.getCodeObject(event);
    if (codeObj && codeObj.labels.length) {
      labels.push(...codeObj.labels);
    }

    return labels;
  }

  getCodeObject(event) {
    return this.functionObjects[`${event.path}:${event.lineno}`];
  }
}

exports.AppMap = AppMap;
exports.CallTree = CallTree;
exports.ClassMap = ClassMap;
exports.CodeObject = CodeObject;
exports.CodeObjectType = CodeObjectType;
exports.Event = Event;
exports.EventInfo = EventInfo;
exports.EventNavigator = EventNavigator;
exports.EventSource = EventSource;
exports.addHiddenProperty = addHiddenProperty;
exports.appMapObjectCompare = appMapObjectCompare;
exports.arrayCompare = arrayCompare;
exports.buildAppMap = buildAppMap;
exports.buildLabels = buildLabels;
exports.buildQueryAST = buildQueryAST;
exports.capitalizeString = capitalizeString;
exports.fullyQualifiedFunctionName = fullyQualifiedFunctionName;
exports.getHttpLabel = getHttpLabel;
exports.getLabel = getLabel;
exports.getRepositoryUrl = getRepositoryUrl;
exports.getRootEvents = getRootEvents;
exports.getSqlLabel = getSqlLabel;
exports.getSqlLabelFromString = getSqlLabelFromString;
exports.hasProp = hasProp;
exports.hashEvent = hashEvent;
exports.hashHttp = hashHttp;
exports.hashSql = hashSql;
exports.hashify = hashify;
exports.httpCompare = httpCompare;
exports.identityHashEvent = identityHashEvent;
exports.isCommand = isCommand;
exports.isFalsey = isFalsey;
exports.normalizeSQL = normalizeSQL;
exports.resolveDifferences = resolveDifferences;
exports.setCompare = setCompare;
exports.sizeof = sizeof;
exports.sqlCompare = sqlCompare;
exports.tokenizeIdentifier = tokenizeIdentifier;
